/* Generate kernels for performing interpolations needed in twist-shift BCs. */

load("modal-basis");
load("out-scripts");
fpprec : 24$

pVars : [X, Y, Z, VX, VY, VZ]$

writeCIncrExprs1sub(lhs, rhs, sublist) := block([expr],
  /* Perform some substitutions before printing. No expand. */
  expr : float(rhs),
  for i : 1 thru length(expr) do (
    if expr[i] # 0.0 then (
      ep     : string(expr[i]),
      outStr : ssubst(sublist[1][2],sublist[1][1],ep),
      for s : 2 thru length(sublist) do (
        outStr : ssubst(sublist[s][2],sublist[s][1],outStr)
      ),
      printf(fh, "  ~a += ~a; ~%", lhs[i-1], outStr)
    )
  )
)$

calcTwistShiftInterpolationOp(fh, funcNm, dim, basisFun, pMax) := block([],
  /* Interpolation operator to transferring a field from one z-end of the
     simulation to the other holding x and toroidal angle phi constant. Requires interpolation
     because a non-rectangular area of one z-end contributes to a single cell and the other z-end.
     This kernel is called to compute contribution from a single source grid cell, to a single
     destination grid cell. */
  kill(varsC, varsP, basisC, basisP),

  /* Will need 1D basis for the y-shift. */
  load(sconcat("basis-precalc/basis", basisFun, 1, "x")),
  basisC1D : makelist(0,i,1,length(basisC)),
  for i : 1 thru length(basisC) do (basisC1D[i] : copylist(basisC[i])),
  vars1D  : varsC,

  /* For now assume dim=2. */
  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),
  vars : varsC,

  interpDims    : makelist(i,i,1,dim),
  numInterpDims : length(interpDims),

  for polyOrder : 1 thru pMax do (
  
    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(const double *xLimLo, const double *xLimUp, const double *fldSrc, double *fldDest) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // xLimUp:  1D DG expansion of the function xLimLo(y) giving the lower limit of the x integral.~%"),
    printf(fh, "  // xLimLo:  1D DG expansion of the function xLimUp(y) giving the upper limit of the x integral.~%"),
    printf(fh, "  // wSrc:    cell center of source grid cell.~%"),
    printf(fh, "  // wDest:   cell center of destination grid cell.~%"),
    printf(fh, "  // dxSrc:   cell length of source grid cell.~%"),
    printf(fh, "  // dxDest:  cell length of destination grid cell.~%"),
    printf(fh, "  // fldSrc:  source grid field.~%"),
    printf(fh, "  // fldDest: destination grid field.~%"),
    printf(fh, "~%"),

    basis1D : basisC1D[polyOrder],  /* This need not use the same polyOrder as fldSrc/fldDest. */
    numB1D  : length(basis1D),

    xLimLo_e : doExpand1(xLimLo,subst(x=y,basis1D)),
    xLimUp_e : doExpand1(xLimUp,subst(x=y,basis1D)),

    basis : basisC[polyOrder],
    numB  : length(basis),

    intLimits : makelist([-1,1], d, 1, dim),
    /* The x-integral limits will depend on the yShift. */
    intLimits[1] : [xLimLo_e, xLimUp_e],

    /* Create a variable saving y-limits of integration. */
    printf(fh, "  double eLo[~a];~%", dim),
    printf(fh, "  double eUp[~a];~%", dim),
    for d : 1 thru dim-1 do (
      printf(fh, "  eLo[~a] = std::max(-1.0,~a);~%", d, float(intLimits[d+1][1])),
      printf(fh, "  eUp[~a] = std::min( 1.0,~a);~%", d, float(intLimits[d+1][2]))
    ),
    printf(fh, "~%"),
  
    /* Field expansions and list of coefficients. */
    fldSrc_e  : doExpand1(fldSrc,basis),
    fldSrc_c  : makelist(fldSrc[i],i,0,numB-1),
  
    /* Create a table of the relationship between the logical coordinates
       in each direction of the source and destination cells, that is, the linear map
         xi_s = L(xi_d)
       where xi_s and xi_d are the is the source and destination logical coordinates. */
    varMap : makelist(vars[i],i,1,dim),
    for dI : 1 thru numInterpDims do (
      d : interpDims[dI],
      varMap[d] : vars[d]
    ),
  
    /* Compute the inner product, on fine grid of current cell,
       of the coarse field times the basis fine-grid functions. */
    intLims : makelist([eLo[d-1], eUp[d-1]],d,1,dim),
    intLims[1] : [xLimLo_e, xLimUp_e],
    IfldDest   : fullratsimp(calcInnerProdListGen(vars,intLims,1.0,basis,subst(makelist(vars[i]=varMap[i],i,1,dim),fldSrc_e))),
  
    /* In general these expressions are very complex. It would be beneficial to
       perform some kind of common subexpression elimination. For now we'll just eliminate the exponents. */
    subList : [],
    maxExponent : 8,
    expQ        : [eLo, eUp],
    for eI : 1 thru length(expQ) do (
      for f : 2 thru maxExponent do (
        for d : 0 thru dim-1 do (
          doSub : false,
          for k : 1 thru numB do (
            if (not freeof(expQ[eI][d]^f,IfldDest[k])) then ( doSub : true )
          ),
          if (doSub) then (
            /* Define a separate variable. */
            lhsS : sconcat("  double ",string(expQ[eI]),d,"R",f),
            rhsS : sconcat("std::pow(",string(expQ[eI][d]),",",f,");~%"),
            printf(fh, sconcat(lhsS," = ",rhsS)),
            /* Add to the string substitution list, used in writing file. */
            subList : append(subList,[[sconcat(string(expQ[eI][d]), "^",f), sconcat(string(expQ[eI]),d,"R",f)]])
          )
        )
      )
    ),
    expR        : [xLimLo, xLimUp],
    for eI : 1 thru length(expR) do (
      for f : 2 thru maxExponent do (
        for j : 0 thru numB1D-1 do (
          doSub : false,
          for k : 1 thru numB do (
            if (not freeof(expR[eI][j]^f,IfldDest[k])) then ( doSub : true )
          ),
          if (doSub) then (
            /* Define a separate variable. */
            lhsS : sconcat("  double ",string(expR[eI]),j,"R",f),
            rhsS : sconcat("std::pow(",string(expR[eI][j]),",",f,");~%"),
            printf(fh, sconcat(lhsS," = ",rhsS)),
            /* Add to the string substitution list, used in writing file. */
            subList : append(subList,[[sconcat(string(expR[eI][j]), "^",f), sconcat(string(expR[eI]),j,"R",f)]])
          )
        )
      )
    ),
    printf(fh, "~%"),
  
    writeCIncrExprs1sub(fldDest,IfldDest,subList),
    printf(fh, "~%"),
  
    printf(fh, "}~%"),
    printf(fh, "~%")

  )
)$


calcTwistShiftInterpOp_xLimFuncOfY(fh, funcNm, dim, basisFun, pMax) := block([],
  /* Interpolation operator used in transferring a field from one z-end of the
     simulation to the other holding x and toroidal angle phi constant. Requires interpolation
     because a non-rectangular area of one z-end contributes to a single cell and the other z-end.
     This kernel is called to compute contribution from a single source grid cell, to a single
     destination grid cell. The contribution from the source cell is computed via a 2D integral
     where the y-limits are constants and the x-limits are functions of y. */
  kill(varsC, varsP, basisC, basisP),

  /* Will need 1D basis for the y-shift. */
  load(sconcat("basis-precalc/basis", basisFun, 1, "x")),
  basisC1D : makelist(0,i,1,length(basisC)),
  for i : 1 thru length(basisC) do (basisC1D[i] : copylist(basisC[i])),
  vars1D  : varsC,

  /* For now assume dim=2. */
  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),
  vars : varsC,

  interpDims    : makelist(i,i,1,dim),
  numInterpDims : length(interpDims),

  for polyOrder : 1 thru pMax do (
  
    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(const double *xLimLo, const double *xLimUp, const double yLimLo, const double yLimUp, const double *fldSrc, double *fldDest) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // xLimUp:  1D DG expansion of the function xLimLo(y) giving the lower limit of the x integral.~%"),
    printf(fh, "  // xLimLo:  1D DG expansion of the function xLimUp(y) giving the upper limit of the x integral.~%"),
    printf(fh, "  // yLimUp:  lower limit of the y integral in [-1,1] normalized space.~%"),
    printf(fh, "  // yLimLo:  upper limit of the y integral in [-1,1] normalized space.~%"),
    printf(fh, "  // fldSrc:  source grid field.~%"),
    printf(fh, "  // fldDest: destination grid field.~%"),
    printf(fh, "~%"),

    basis1D : basisC1D[polyOrder],  /* This need not use the same polyOrder as fldSrc/fldDest. */
    numB1D  : length(basis1D),

    xLimLo_e : doExpand1(xLimLo,subst(x=y,basis1D)),
    xLimUp_e : doExpand1(xLimUp,subst(x=y,basis1D)),

    basis : basisC[polyOrder],
    numB  : length(basis),

    intLims    : makelist([-1,1], d, 1, dim),
    intLims[1] : [xLimLo_e, xLimUp_e],   /* The x-integral limits will depend on the yShift. */
    intLims[2] : [yLimLo, yLimUp],

    /* Field expansions and list of coefficients. */
    fldSrc_e  : doExpand1(fldSrc,basis),
    fldSrc_c  : makelist(fldSrc[i],i,0,numB-1),
  
    /* Create a table of the relationship between the logical coordinates
       in each direction of the source and destination cells, that is, the linear map
         xi_s = L(xi_d)
       where xi_s and xi_d are the is the source and destination logical coordinates. */
    varMap : makelist(vars[i],i,1,dim),
    for dI : 1 thru numInterpDims do (
      d : interpDims[dI],
      varMap[d] : vars[d]
    ),
  
    /* Compute the inner product, on dest grid of current cell,
       of the source field times the dest-grid basis functions (in this case src and dest basis are the same). */
    IfldDest : fullratsimp(calcInnerProdListGen(vars,intLims,1.0,basis,subst(makelist(vars[i]=varMap[i],i,1,dim),fldSrc_e))),
  
    /* In general these expressions are very complex. It would be beneficial to
       perform some kind of common subexpression elimination. For now we'll just eliminate the exponents. */
    subList : [],
    maxExponent : 8,
    expQ        : [yLimLo, yLimUp],
    for eI : 1 thru length(expQ) do (
      for f : 2 thru maxExponent do (
        doSub : false,
        for k : 1 thru numB do (
          if (not freeof(expQ[eI]^f,IfldDest[k])) then ( doSub : true )
        ),
        if (doSub) then (
          /* Define a separate variable. */
          lhsS : sconcat("  double ",string(expQ[eI]),"R",f),
          rhsS : sconcat("std::pow(",string(expQ[eI]),",",f,");~%"),
          printf(fh, sconcat(lhsS," = ",rhsS)),
          /* Add to the string substitution list, used in writing file. */
          subList : append(subList,[[sconcat(string(expQ[eI]), "^",f), sconcat(string(expQ[eI]),"R",f)]])
        )
      )
    ),
    expR        : [xLimLo, xLimUp],
    for eI : 1 thru length(expR) do (
      for f : 2 thru maxExponent do (
        for j : 0 thru numB1D-1 do (
          doSub : false,
          for k : 1 thru numB do (
            if (not freeof(expR[eI][j]^f,IfldDest[k])) then ( doSub : true )
          ),
          if (doSub) then (
            /* Define a separate variable. */
            lhsS : sconcat("  double ",string(expR[eI]),j,"R",f),
            rhsS : sconcat("std::pow(",string(expR[eI][j]),",",f,");~%"),
            printf(fh, sconcat(lhsS," = ",rhsS)),
            /* Add to the string substitution list, used in writing file. */
            subList : append(subList,[[sconcat(string(expR[eI][j]), "^",f), sconcat(string(expR[eI]),j,"R",f)]])
          )
        )
      )
    ),
    printf(fh, "~%"),
  
    writeCIncrExprs1sub(fldDest,IfldDest,subList),
    printf(fh, "~%"),
  
    printf(fh, "}~%"),
    printf(fh, "~%")

  )
)$

calcTwistShiftInterpOp_xLimDG(fh, funcNm, dim, basisFun, pMax) := block([],
  /* Interpolation operator used in transferring a field from one z-end of the
     simulation to the other holding x and toroidal angle phi constant. Requires interpolation
     because a non-rectangular area of one z-end contributes to a single cell at the other z-end.
     This kernel is called to compute contribution from a single source grid cell, to a single
     destination grid cell. The contribution from the source cell is computed via a 2D integral
     where the y-limits are constants and the x-limits are functions of y. The x-limits are given
     by a DG (polynomial expansion), defined in a [-1,1] logical space that is a sub-region of the
     source cell. */
  kill(varsC, varsP, basisC, basisP),

  /* Will need 1D basis for the y-shift. */
  load(sconcat("basis-precalc/basis", basisFun, 1, "x")),
  basisC1D : makelist(0,i,1,length(basisC)),
  for i : 1 thru length(basisC) do (basisC1D[i] : copylist(basisC[i])),
  vars1D  : varsC,

  /* For now assume dim=2. */
  kill(varsC, varsP, basisC, basisP),
  load(sconcat("basis-precalc/basis", basisFun, dim, "x")),
  vars : varsC,

  interpDims    : makelist(i,i,1,dim),
  numInterpDims : length(interpDims),

  for polyOrder : 1 thru pMax do (
  
    /* Function declaration with input/output variables. */
    printf(fh, "void ~a_P~a(const double *xLimLo, const double *xLimUp, const double yLimLo, const double yLimUp, const double dyLim, const double ycLim, const double *fldSrc, double *fldDest) ~%{ ~%", funcNm, polyOrder),
    printf(fh, "  // xLimUp:  1D DG expansion of the function xLimLo(y) giving the lower limit of the x integral.~%"),
    printf(fh, "  // xLimLo:  1D DG expansion of the function xLimUp(y) giving the upper limit of the x integral.~%"),
    printf(fh, "  // yLimUp:  lower limit of the y integral in [-1,1] normalized space.~%"),
    printf(fh, "  // yLimLo:  upper limit of the y integral in [-1,1] normalized space.~%"),
    printf(fh, "  // dyLimSpace:  length of the subregion in which the DG expansion of the yLimLo/yLimUp functions are defined.~%"),
    printf(fh, "  // ycLimSpace:  logical center of the subregion in which the DG expansion of the yLimLo/yLimUp functions are defined.~%"),
    printf(fh, "  // fldDest: destination grid field.~%"),
    printf(fh, "~%"),

    basis1D : basisC1D[polyOrder],  /* This need not use the same polyOrder as fldSrc/fldDest. */
    numB1D  : length(basis1D),

    xLimLo_e : doExpand1(xLimLo,subst(x=y,basis1D)),
    xLimUp_e : doExpand1(xLimUp,subst(x=y,basis1D)),
    /* The y-variable used in the inner product below is different to the
       y-variable in xLimLo/xLimUp because the former corresponds to the logical space of the source cell,
       while the latter to a sub-region of that logical (y) space. They a related by a shift and a scaling. */
    dyCell : 2,
    ycCell : 0,
    yMap : (2/dyLim)*(ycCell-ycLim+(dyCell/2)*y),

    xLimLo_e : subst(y=yMap,xLimLo_e),
    xLimUp_e : subst(y=yMap,xLimUp_e),

    basis : basisC[polyOrder],
    numB  : length(basis),

    /* The x-integral limits will depend on the yShift. */
    intLims : [ [xLimLo_e, xLimUp_e], [yLimLo, yLimUp] ],

    /* Field expansion and list of coefficients. */
    fldSrc_e  : doExpand1(fldSrc,basis),
    fldSrc_c  : makelist(fldSrc[i],i,0,numB-1),
  
    /* Compute the inner product, on dest grid of current cell,
       of the source field times the dest-grid basis functions (in this case src and dest basis are the same). */
    fldDest_c : fullratsimp(calcInnerProdListGen(vars,intLims,1.0,basis,fldSrc_e)),
  
    /* In general these expressions are very complex. It would be beneficial to
       perform some kind of common subexpression elimination. For now we'll just eliminate the exponents. */
    subList : [],
    maxExponent : 8,
    expQ        : [yLimLo, yLimUp, dyLim, ycLim],
    for eI : 1 thru length(expQ) do (
      for f : 2 thru maxExponent do (
        doSub : false,
        for k : 1 thru numB do (
          if (not freeof(expQ[eI]^f,fldDest_c[k])) then ( doSub : true )
        ),
        if (doSub) then (
          /* Define a separate variable. */
          lhsS : sconcat("  double ",string(expQ[eI]),"R",f),
          rhsS : sconcat("std::pow(",string(expQ[eI]),",",f,");~%"),
          printf(fh, sconcat(lhsS," = ",rhsS)),
          /* Add to the string substitution list, used in writing file. */
          subList : append(subList,[[sconcat(string(expQ[eI]), "^",f), sconcat(string(expQ[eI]),"R",f)]])
        )
      )
    ),
    expR        : [xLimLo, xLimUp],
    for eI : 1 thru length(expR) do (
      for f : 2 thru maxExponent do (
        for j : 0 thru numB1D-1 do (
          doSub : false,
          for k : 1 thru numB do (
            if (not freeof(expR[eI][j]^f,fldDest_c[k])) then ( doSub : true )
          ),
          if (doSub) then (
            /* Define a separate variable. */
            lhsS : sconcat("  double ",string(expR[eI]),j,"R",f),
            rhsS : sconcat("std::pow(",string(expR[eI][j]),",",f,");~%"),
            printf(fh, sconcat(lhsS," = ",rhsS)),
            /* Add to the string substitution list, used in writing file. */
            subList : append(subList,[[sconcat(string(expR[eI][j]), "^",f), sconcat(string(expR[eI]),j,"R",f)]])
          )
        )
      )
    ),
    printf(fh, "~%"),
  
    writeCIncrExprs1sub(fldDest,fldDest_c,subList),
    printf(fh, "~%"),
  
    printf(fh, "}~%"),
    printf(fh, "~%")

  )
)$
